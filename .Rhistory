}, ignoreNULL = FALSE)
risk_free_rate <- eventReactive(input$update, {
input$rfrate
}, ignoreNULL = FALSE)
# Go to next page when a confirming button is pressed
observeEvent(input$update, {
updateTabsetPanel(session, "tabset1",
selected = "methodpanel")
})
observeEvent(input$update2, {
updateTabsetPanel(session, "tabset1",
selected = "resultspanel")
})
# -- Making a general function for user inputs to be applied to stock_input
dataInput <- eventReactive(input$update, {
input_function(tickers1(), input$fromdate, input$todate)
}, ignoreNULL = FALSE)
# -- Making another input function to be able to use subsets from the stock_opt_vol and stock_opt_sharpe functions.
vol_output <- eventReactive(input$update, {
stock_opt_vol(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sharpe_output <- eventReactive(input$update, {
stock_opt_sharpe(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sortino_output <- eventReactive(input$update, {
stock_opt_sortino(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
############ END OF INPUT PROCESSING ##########
########### GENERATING OUTPUTS #############
# Generate output for optimal volume
output$vstock_list <-renderDataTable({
stocks_with_industry # Here we output a subset of vol_input
})
# Generate output for stats based upon chosen method
output$stats <- renderTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[4]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[4]]
}
else{
vol_output()[[4]]
}
})
# Generate output for optimal volume based upon chosen method
output$volstats <- renderDataTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[3]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[3]]
}
else{
vol_output()[[3]]
}
})
################# PLOT and EXTRA page #############
# Generate output for portfolio industry percentages
output$vpiechart <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sharpe_output()[[2]]))
}
else if (x == "Sortino Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sortino_output()[[2]]))
}
else{
portfolio_industry(dataInput()[[1]], (vol_output()[[2]]))
}
})
# Generate output for the correlation plot
output$vcorr_plot <- renderPlot({
correlation_plot(dataInput()[[4]])
})
# Generate output for the returns histogram
output$vreturns_hist <- renderPlot({
returns_hist(dataInput()[[5]])
})
# Genereate output for the stock price history
output$vstock_price_history <- renderPlot({
stock_price_history(dataInput()[[2]])
})
# Generate output for the efficiency frontier
output$vefficency_frontier <- renderPlot({
efficency_frontier(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]], n = 5000)
})
# Generate output for the S&P500 comparison
output$vcompare_SP500 <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
compare_SP500(as.matrix(sharpe_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else if (x == "Sortino Ratio Maximizing"){
compare_SP500(as.matrix(sortino_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else{
compare_SP500(as.matrix(vol_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
})
}
shinyApp(ui = ui, server = server) # Combine it into the app
shinyApp(ui = ui, server = server) # Combine it into the app
server <- function(input, output, session) {
############################### PROCESSING INPUTS ###############################################
# Update stock_input with input from dateInput "fromdate" og "todate"
# eventReactive means that it updates the function inputs every time user clicks the "update" button
#  observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
#    updateSelectInput(session, "manual",
#                      choices = stocks_with_industry$Symbol[stocks_with_industry$Industry != input$industry]) # The user will not be able to chose a stock within the unwanted industry
#
#  })
`%notin%` <- Negate(`%in%`) # Making an opposite of %in%
choice1 <-  reactive({
stocks_with_industry$Symbol[stocks_with_industry$Industry %notin% input$industry]
})
observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
updateSelectInput(session, "manual",
choices = choice1()) # The user will not be able to chose a stock within the unwanted industry
})
observeEvent(input$random, {  # Get random portfolio which does not include chosen undesired industry - the user can select the amount of stocks in the random portfolio
updateSelectInput(session, "manual",
selected = sample(choice1(), input$n_unique_stocks))
})
observe({
x <- input$n_unique_stocks
#    if (x < 100 & x > 50){
#      showNotification("Loading may now take above 1 minute due to a large amount of stocks", type = "warning")
#    }
if (x > 100){
showNotification("Please select 100 or less stocks", type = "error")
}
else {
# do nothing
}
})
tickers1 <- eventReactive(input$update, {
input$manual
}, ignoreNULL = FALSE)
risk_free_rate <- eventReactive(input$update, {
input$rfrate
}, ignoreNULL = FALSE)
# Go to next page when a confirming button is pressed
observeEvent(input$update, {
updateTabsetPanel(session, "tabset1",
selected = "methodpanel")
})
observeEvent(input$update2, {
updateTabsetPanel(session, "tabset1",
selected = "resultspanel")
})
# -- Making a general function for user inputs to be applied to stock_input
dataInput <- eventReactive(input$update, {
input_function(tickers1(), input$fromdate, input$todate)
}, ignoreNULL = FALSE)
# -- Making another input function to be able to use subsets from the stock_opt_vol and stock_opt_sharpe functions.
vol_output <- eventReactive(input$update, {
stock_opt_vol(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sharpe_output <- eventReactive(input$update, {
stock_opt_sharpe(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sortino_output <- eventReactive(input$update, {
stock_opt_sortino(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
############ END OF INPUT PROCESSING ##########
########### GENERATING OUTPUTS #############
# Generate output for optimal volume
output$vstock_list <-renderDataTable({
stocks_with_industry # Here we output a subset of vol_input
})
# Generate output for stats based upon chosen method
output$stats <- renderTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[4]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[4]]
}
else{
vol_output()[[4]]
}
})
# Generate output for optimal volume based upon chosen method
output$volstats <- renderDataTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[3]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[3]]
}
else{
vol_output()[[3]]
}
})
################# PLOT and EXTRA page #############
# Generate output for portfolio industry percentages
output$vpiechart <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sharpe_output()[[2]]))
}
else if (x == "Sortino Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sortino_output()[[2]]))
}
else{
portfolio_industry(dataInput()[[1]], (vol_output()[[2]]))
}
})
# Generate output for the correlation plot
output$vcorr_plot <- renderPlot({
correlation_plot(dataInput()[[4]])
})
# Generate output for the returns histogram
output$vreturns_hist <- renderPlot({
returns_hist(dataInput()[[5]])
})
# Genereate output for the stock price history
output$vstock_price_history <- renderPlot({
stock_price_history(dataInput()[[2]])
})
# Generate output for the efficiency frontier
output$vefficency_frontier <- renderPlot({
efficency_frontier(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]], n = 5000)
})
# Generate output for the S&P500 comparison
output$vcompare_SP500 <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
compare_SP500(as.matrix(sharpe_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else if (x == "Sortino Ratio Maximizing"){
compare_SP500(as.matrix(sortino_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else{
compare_SP500(as.matrix(vol_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
})
}
shinyApp(ui = ui, server = server) # Combine it into the app
source("Ban400-Functions.R")
server <- function(input, output, session) {
############################### PROCESSING INPUTS ###############################################
# Update stock_input with input from dateInput "fromdate" og "todate"
# eventReactive means that it updates the function inputs every time user clicks the "update" button
#  observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
#    updateSelectInput(session, "manual",
#                      choices = stocks_with_industry$Symbol[stocks_with_industry$Industry != input$industry]) # The user will not be able to chose a stock within the unwanted industry
#
#  })
`%notin%` <- Negate(`%in%`) # Making an opposite of %in%
choice1 <-  reactive({
stocks_with_industry$Symbol[stocks_with_industry$Industry %notin% input$industry]
})
observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
updateSelectInput(session, "manual",
choices = choice1()) # The user will not be able to chose a stock within the unwanted industry
})
observeEvent(input$random, {  # Get random portfolio which does not include chosen undesired industry - the user can select the amount of stocks in the random portfolio
updateSelectInput(session, "manual",
selected = sample(choice1(), input$n_unique_stocks))
})
n_stocks_failure <- reactive({
validate(
error1(input$n_unique_stocks)
)
})
tickers1 <- eventReactive(input$update, {
input$manual
}, ignoreNULL = FALSE)
risk_free_rate <- eventReactive(input$update, {
input$rfrate
}, ignoreNULL = FALSE)
# Go to next page when a confirming button is pressed
observeEvent(input$update, {
updateTabsetPanel(session, "tabset1",
selected = "methodpanel")
})
observeEvent(input$update2, {
updateTabsetPanel(session, "tabset1",
selected = "resultspanel")
})
# -- Making a general function for user inputs to be applied to stock_input
dataInput <- eventReactive(input$update, {
input_function(tickers1(), input$fromdate, input$todate)
}, ignoreNULL = FALSE)
# -- Making another input function to be able to use subsets from the stock_opt_vol and stock_opt_sharpe functions.
vol_output <- eventReactive(input$update, {
stock_opt_vol(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sharpe_output <- eventReactive(input$update, {
stock_opt_sharpe(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sortino_output <- eventReactive(input$update, {
stock_opt_sortino(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
############ END OF INPUT PROCESSING ##########
########### GENERATING OUTPUTS #############
# Generate output for optimal volume
output$vstock_list <-renderDataTable({
stocks_with_industry # Here we output a subset of vol_input
})
# Generate output for stats based upon chosen method
output$stats <- renderTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[4]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[4]]
}
else{
vol_output()[[4]]
}
})
# Generate output for optimal volume based upon chosen method
output$volstats <- renderDataTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[3]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[3]]
}
else{
vol_output()[[3]]
}
})
################# PLOT and EXTRA page #############
# Generate output for portfolio industry percentages
output$vpiechart <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sharpe_output()[[2]]))
}
else if (x == "Sortino Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sortino_output()[[2]]))
}
else{
portfolio_industry(dataInput()[[1]], (vol_output()[[2]]))
}
})
# Generate output for the correlation plot
output$vcorr_plot <- renderPlot({
correlation_plot(dataInput()[[4]])
})
# Generate output for the returns histogram
output$vreturns_hist <- renderPlot({
returns_hist(dataInput()[[5]])
})
# Genereate output for the stock price history
output$vstock_price_history <- renderPlot({
stock_price_history(dataInput()[[2]])
})
# Generate output for the efficiency frontier
output$vefficency_frontier <- renderPlot({
efficency_frontier(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]], n = 5000)
})
# Generate output for the S&P500 comparison
output$vcompare_SP500 <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
compare_SP500(as.matrix(sharpe_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else if (x == "Sortino Ratio Maximizing"){
compare_SP500(as.matrix(sortino_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else{
compare_SP500(as.matrix(vol_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
})
}
shinyApp(ui = ui, server = server) # Combine it into the app
server <- function(input, output, session) {
############################### PROCESSING INPUTS ###############################################
# Update stock_input with input from dateInput "fromdate" og "todate"
# eventReactive means that it updates the function inputs every time user clicks the "update" button
#  observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
#    updateSelectInput(session, "manual",
#                      choices = stocks_with_industry$Symbol[stocks_with_industry$Industry != input$industry]) # The user will not be able to chose a stock within the unwanted industry
#
#  })
`%notin%` <- Negate(`%in%`) # Making an opposite of %in%
choice1 <-  reactive({
stocks_with_industry$Symbol[stocks_with_industry$Industry %notin% input$industry]
})
observe({  # Update the choice list - currently only work when the user select one industry. It does not filter out if the user select more than one industry (needs to be fixed)
updateSelectInput(session, "manual",
choices = choice1()) # The user will not be able to chose a stock within the unwanted industry
})
observeEvent(input$random, {  # Get random portfolio which does not include chosen undesired industry - the user can select the amount of stocks in the random portfolio
updateSelectInput(session, "manual",
selected = sample(choice1(), input$n_unique_stocks))
})
n_stocks_failure <- reactive({
validate(
error1(input$n_unique_stocks)
)
})
output$vstock_list <- renderDataTable({
n_stocks_failure()
})
tickers1 <- eventReactive(input$update, {
input$manual
}, ignoreNULL = FALSE)
risk_free_rate <- eventReactive(input$update, {
input$rfrate
}, ignoreNULL = FALSE)
# Go to next page when a confirming button is pressed
observeEvent(input$update, {
updateTabsetPanel(session, "tabset1",
selected = "methodpanel")
})
observeEvent(input$update2, {
updateTabsetPanel(session, "tabset1",
selected = "resultspanel")
})
# -- Making a general function for user inputs to be applied to stock_input
dataInput <- eventReactive(input$update, {
input_function(tickers1(), input$fromdate, input$todate)
}, ignoreNULL = FALSE)
# -- Making another input function to be able to use subsets from the stock_opt_vol and stock_opt_sharpe functions.
vol_output <- eventReactive(input$update, {
stock_opt_vol(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sharpe_output <- eventReactive(input$update, {
stock_opt_sharpe(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
sortino_output <- eventReactive(input$update, {
stock_opt_sortino(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]])
}, ignoreNULL = FALSE)
############ END OF INPUT PROCESSING ##########
########### GENERATING OUTPUTS #############
# Generate output for optimal volume
output$vstock_list <-renderDataTable({
stocks_with_industry # Here we output a subset of vol_input
})
# Generate output for stats based upon chosen method
output$stats <- renderTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[4]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[4]]
}
else{
vol_output()[[4]]
}
})
# Generate output for optimal volume based upon chosen method
output$volstats <- renderDataTable({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
sharpe_output()[[3]]
}
else if (x == "Sortino Ratio Maximizing"){
sortino_output()[[3]]
}
else{
vol_output()[[3]]
}
})
################# PLOT and EXTRA page #############
# Generate output for portfolio industry percentages
output$vpiechart <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sharpe_output()[[2]]))
}
else if (x == "Sortino Ratio Maximizing"){
portfolio_industry(dataInput()[[1]], (sortino_output()[[2]]))
}
else{
portfolio_industry(dataInput()[[1]], (vol_output()[[2]]))
}
})
# Generate output for the correlation plot
output$vcorr_plot <- renderPlot({
correlation_plot(dataInput()[[4]])
})
# Generate output for the returns histogram
output$vreturns_hist <- renderPlot({
returns_hist(dataInput()[[5]])
})
# Genereate output for the stock price history
output$vstock_price_history <- renderPlot({
stock_price_history(dataInput()[[2]])
})
# Generate output for the efficiency frontier
output$vefficency_frontier <- renderPlot({
efficency_frontier(dataInput()[[1]], dataInput()[[7]], dataInput()[[3]], dataInput()[[6]], n = 5000)
})
# Generate output for the S&P500 comparison
output$vcompare_SP500 <- renderPlot({
x <- input$method
if (x == "Sharpe Ratio Maximizing"){
compare_SP500(as.matrix(sharpe_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else if (x == "Sortino Ratio Maximizing"){
compare_SP500(as.matrix(sortino_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
else{
compare_SP500(as.matrix(vol_output()[[2]]), dataInput()[[1]], input$fromdate, input$todate)
}
})
}
shinyApp(ui = ui, server = server) # Combine it into the app
